from PIL import Image, ImageSequence
import sys, os
    
def gifblender(filename):
    stem,ext = os.path.splitext(filename)
    in_gif = Image.open(filename)
    width,height = in_gif.size
    num_frms = num_frames(in_gif)

    aggs = get_aggregate_RGB(in_gif)
    avgs = aggregates_to_avg(aggs, num_frms)
    imgdata = make_image_list(avgs)    
    
    out_png = Image.new('RGB', (width, height))
    out_png.putdata(imgdata)
    out_png.save(stem + '_smoosh.png')
    
def num_frames(gif):
    i = 1
    gif.seek(0)
    while True:
        try:
            gif.seek(i)
        except EOFError:
            gif.seek(0)
            return i
        i += 1
    
def make_image_list(image_dict):
    '''Input: a dictionary where the keys are 1D coordinates and the values are 3-element tuples representing (average) RGB intensity values for each coordinate.

    Output: a list of three-element tuples representing RGB values, ordered according to the 1D coordinate keys of the input dictionary.'''
    dict_list = sorted(image_dict.items())
    imgdata = []
    for coord in dict_list:
        imgdata.append(coord[1])
    return imgdata

def avg_coords(coord_dict):
    '''Input: a dict with keys being 1D coordinates and values being lists of 4-element tuples representing different RGBA intensities for that coordinate in different frames of the animated gif.
    Output: a dict with the same keys, but each key having only one 3-element tuple as its value, representing its *average* RGB intensity.'''
    result = {}
    for coord in coord_dict:
        r_vals = []
        b_vals = []
        g_vals = []
        for pixel in coord_dict[coord]:
            if pixel[3] != 255:
                r_vals.append(clip(coord_dict[coord][0][0]))
                g_vals.append(clip(coord_dict[coord][0][1]))
                b_vals.append(clip(coord_dict[coord][0][2]))
            else:
                r_vals.append(clip(pixel[0]))
                g_vals.append(clip(pixel[1]))
                b_vals.append(clip(pixel[2]))
        avg_r = mean(r_vals)
        avg_g = mean(g_vals)
        avg_b = mean(b_vals)
        result[coord] = (avg_r, avg_g, avg_b)
    return result

def get_aggregate_RGB(gif):
    '''Input: an image object generated by the PIL library. In particular, an animated gif.
    Output: a dictionary where the keys are 1D coordinates and the values are 3-element tuples where each element is the sum of the intensities across the whole sequence of the R G or B of the pixel at that coordinate.'''
    aggregates = {}
    n = 1
    for frame in ImageSequence.Iterator(gif):
        raw_frame = frame.copy()
        rgb_frame = frame.copy().convert('RGBA')
        data = list(rgb_frame.getdata())

        for coord in range(len(data)):
            r,g,b,alpha = data[coord]
            if alpha == 255:
                try:
                    aggregates[coord][0] += r
                    aggregates[coord][1] += g
                    aggregates[coord][2] += b
                except KeyError:
                    aggregates[coord] = [r,g,b]
            else:
                try:
                    init_r = aggregates[coord][0] / (n - 1)
                    init_g = aggregates[coord][1] / (n - 1)
                    init_b = aggregates[coord][2] / (n - 1)
                    aggregates[coord][0] += init_r
                    aggregates[coord][1] += init_g
                    aggregates[coord][2] += init_b
                except KeyError:
                    aggregates[coord] = [255,255,255]
        n += 1
        
    return aggregates

def aggregates_to_avg(aggregates,num_frames):
    '''Inputs: a dict containing coords and their aggregate RGB values (3-element list) over entire sequence. Plus number of frames in sequence.
    Output: a dict containing coords and their average RGB values (3-element tuple)'''
    averages = {}
    for coord in aggregates:
        avg_r = int(round(aggregates[coord][0] / float(num_frames)))
        avg_g = int(round(aggregates[coord][1] / float(num_frames)))
        avg_b = int(round(aggregates[coord][2] / float(num_frames)))
        averages[coord] = (avg_r,avg_g,avg_b)
    return averages
    
def clip(n):
    """clip(int) -> int

    Restrict the int argument to the range [0,255]
    """
    return max(0, min(255, n))

def mean(list):
    """mean(list) -> int

    Return the closest integer to the arithmetic
    mean of a list of integers.
    """
    return int(round(float(sum(list))/len(list)))