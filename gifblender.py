###############################################################################
#
# ::: GIFBLENDER :::
#
# AUTHOR
#
#    Yoshua Wakeham
#      email: yoshwakeham@gmail.com
#      www: github.com/yoshw
#      tweet: @yoshw
#
# DATE CREATED
#
#    13 November 2013
#
# NOTES
#
#    Gifblender is a simple Python script which blends
#    (that is, averages) all the frames in an animated
#	 GIF image and outputs the result as a single PNG image.
#
#    This program is designed to be used with Python 2.7.
#
# CHANGELOG
#
#    13/11/2013 - Cleaning up code
#	 19/11/2013 - Added all dosctrings, made PEP8 clean
#
###############################################################################

from PIL import Image, ImageSequence
import os


def gifblender(filename):
    '''
    Blends all frames of an animated GIF, by averaging
    the RGB intensity values for each pixel coordinate
    over the duration of the animation. Outputs a single
    PNG image.

    INPUT:
        filename of GIF to blend (string)

    RESULT:
        creates PNG of blended image in the local directory
    '''
    stem, ext = os.path.splitext(filename)
    assert ext == '.gif', 'Wrong input file type.'
    source_gif = Image.open(filename)

    # Get GIF properties
    width, height = source_gif.size
    duration = count_frames(source_gif)

    # Calculate aggregate RGB intensities for
    # each pixel coordinate in source GIF
    aggregate_RGB = get_aggregate_RGB(source_gif)
    # Calculate average RGB values at each coordinate
    avg_RGB = get_avg_RGB(aggregate_RGB, duration)
    # Convert RGB values to list
    img_data = img_dict_to_list(avg_RGB)

    # Write new image
    out_filename = stem + '_blent.png'
    out_png = Image.new('RGB', (width, height))
    out_png.putdata(img_data)
    out_png.save(out_filename)


def count_frames(gif):
    '''
    Return the number of frames in a PIL Image object.
    '''
    gif.seek(0)
    i = 1
    while True:
        try:
            gif.seek(i)
            i += 1
        except EOFError:
            gif.seek(0)
            return i


def get_aggregate_RGB(gif):
    '''
    Takes a PIL image object (tacitly assumed to be a
    multi-frame image, although the function still works
    with a single frame) and aggregates the RGB values at
    each pixel in the image for all frames in the sequence.

    Must first convert the palette-based GIF image to RGBA
    format. If the alpha value of a pixel is less than full
    opacity for a particular frame, the RGB values are
    assumed to be identical to those of the first frame; if
    a pixel in the first frame has less than full opacity, it
    is set to the white pixel.

    INPUT:
        gif
            an image object generated by the PIL library,
            assumed to be a GIF.

    RESULT:
        a dictionary: keys are pixel coordinates, values are
        3-element tuples containing aggregate R, G and B
        intensity values for the pixel at that coordinate.
    '''
    aggregates = {}
    n = 1
    for frame in ImageSequence.Iterator(gif):
        raw_frame = frame.copy()
        rgb_frame = frame.copy().convert('RGBA')
        data = list(rgb_frame.getdata())

        for coord in range(len(data)):
            r, g, b, alpha = data[coord]
            if alpha == 255:
                try:
                    aggregates[coord][0] += r
                    aggregates[coord][1] += g
                    aggregates[coord][2] += b
                except KeyError:
                    aggregates[coord] = [r, g, b]
            else:
                try:
                    init_r = aggregates[coord][0] / (n - 1)
                    init_g = aggregates[coord][1] / (n - 1)
                    init_b = aggregates[coord][2] / (n - 1)
                    aggregates[coord][0] += init_r
                    aggregates[coord][1] += init_g
                    aggregates[coord][2] += init_b
                except KeyError:
                    aggregates[coord] = [255, 255, 255]
        n += 1

    return aggregates


def get_avg_RGB(aggregates, num_frames):
    '''
    Takes a dictionary of pixel coordinates and their
    associated aggregate RGB intensity values. Divides
    these aggregates by the number of frames in the
    animated GIF to give an average (arithmetic mean)
    RGB value for each pixel.

    INPUTS:
        aggregates
            a dictionary: keys are pixel coordinates, values
            are 3-element tuples containing aggregate RGB
            intensity values for the pixel at that coordinate.
        num_frames
            number of frames in animated sequence (an integer)
    RESULT:
        a dictionary: keys are pixel coordinates, values
        are 3-element tuples containing average R, G
        and B intensity values for the pixel at that coordinate.
    '''
    averages = {}
    for coord in aggregates:
        avg_r = int(round(aggregates[coord][0] / float(num_frames)))
        avg_g = int(round(aggregates[coord][1] / float(num_frames)))
        avg_b = int(round(aggregates[coord][2] / float(num_frames)))
        averages[coord] = (avg_r, avg_g, avg_b)
    return averages


def img_dict_to_list(image_dict):
    '''
    Takes a dictionary of pixel coordinates -> RGB intensities
    and returns a sorted list of those RGB values, ready to be
    written to a new PIL Image.

    INPUT:
        image_dict
            a dictionary where the keys are one-dimensional
            pixel coordinates and the values are RGB intensity
            values (3-element tuples) for each coordinate.

    RESULT:
        a list of RGB intensities (3-element tuples), sorted
        according to the pixel coordinates of the input dictionary.
    '''
    sorted_pairs = sorted(image_dict.items())
    img_list = []
    for pair in sorted_pairs:
        RGB = pair[1]
        img_list.append(RGB)
    return img_list
